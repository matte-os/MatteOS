import sys
import subprocess
import re
import argparse
import os

def main():
    parser = argparse.ArgumentParser(description="Generate Kernel Symbol Table")
    parser.add_argument("kernel_elf", help="Path to the kernel ELF file")
    parser.add_argument("--allowed-list", required=True, help="File containing allowed regex patterns")
    parser.add_argument("--nm-tool", default="llvm-nm-17", help="Path to llvm-nm binary")
    parser.add_argument("--cxxfilt-tool", default="c++filt", help="Path to c++filt binary")
    args = parser.parse_args()

    # 1. Compile Regex Patterns
    try:
        with open(args.allowed_list, 'r') as f:
            patterns = [line.strip() for line in f if line.strip() and not line.startswith('#')]

        if not patterns:
            # Fallback if file is empty: Match nothing
            filter_regex = re.compile(r"$.")
        else:
            # Optimize: 'search' with one big regex is faster than looping many small ones
            filter_regex = re.compile('|'.join(patterns))
    except FileNotFoundError:
        print(f"Error: Allowed list file '{args.allowed_list}' not found.", file=sys.stderr)
        sys.exit(1)

    # 2. Extract Symbols (Batch Step 1)
    # We use subprocess to run nm quickly.
    try:
        # -g: Extern only, --defined-only: No undefined symbols
        cmd = [args.nm_tool, "-g", "--defined-only", args.kernel_elf]
        nm_process = subprocess.run(cmd, capture_output=True, text=True, check=True)
    except Exception as e:
        print(f"Error running nm ({args.nm_tool}): {e}", file=sys.stderr)
        sys.exit(1)

    # Parse nm output.
    # Format usually: "0000000080200000 T _Z8SomeFuncv"
    # We need Address and Mangled Name.
    raw_entries = []
    mangled_names = []

    for line in nm_process.stdout.splitlines():
        parts = line.split()
        if len(parts) >= 3:
            addr = parts[0]
            # type = parts[1] (unused)
            name = parts[2]
            raw_entries.append({'addr': addr, 'mangled': name})
            mangled_names.append(name)

    if not raw_entries:
        print("Warning: No symbols found in ELF.", file=sys.stderr)

    # 3. Demangle (Batch Step 2)
    try:
        input_block = "\n".join(mangled_names)
        cxx_process = subprocess.run(
            [args.cxxfilt_tool],
            input=input_block,
            capture_output=True,
            text=True,
            check=True
        )
        demangled_names = cxx_process.stdout.splitlines()
    except Exception as e:
        print(f"Error running c++filt: {e}", file=sys.stderr)
        sys.exit(1)

    # Safety check
    if len(demangled_names) != len(raw_entries):
        print("Error: Demangler output count mismatch.", file=sys.stderr)
        sys.exit(1)

    # 4. Filter & Generate C++
    print("/* Auto-generated by tools/gen_syms.py */")
    print("#include <Kernel/API/KernelSymbols.h>")
    print("")
    print("extern \"C\" {")
    print("    __attribute__((section(\".ksymtab\")))")
    print("    const KernelSymbol k_exported_symbols[] = {")

    match_count = 0

    # Zip the raw data with the demangled output for filtering
    for entry, demangled in zip(raw_entries, demangled_names):
        # Apply the combined regex to the DEMANGLED name
        if filter_regex.search(demangled):
            # Write the MANGLED name to the table (for the linker)
            print(f'        {{ "{entry["mangled"]}", 0x{entry["addr"]} }},')
            match_count += 1

    print("        { nullptr, 0 }")
    print("    };")
    print(f"    const size_t k_exported_symbols_count = {match_count};")
    print("}")

if __name__ == "__main__":
    main()